[⬅️ 상위 README로 이동](../README.md)

## 📘 개념 정리 템플릿

## 📌 목차

* [1. 문자의 기본 입출력](#1-문자의-기본-입출력)
* [2. 버퍼](#2-버퍼)
* [3. 혼공C 11장 도전 실전 예제](#3-혼공c-11장-도전-실전-예제)
* [📌 참고 자료](#-참고-자료)

---

### **1. 문자의 기본 입출력**

###     **1-1. 아스키코드**

- 컴퓨터는 문자를 저장할 때 문자 그 자체의 모양을 저장하지 않는다.
    - **사실 문자라는 건 없다고 생각하는 것이 좋다. 문자는 약속된 정수다.**
- 각 문자마다 고유의 번호를 붙이고 표로 만들어 둔 뒤, 해당 번호를 출력할 때, 자료형이 '문자'일 경우 미리 저장되어 있는 표를 보고 해당 문자를 그려준다.
- 그런데 개발자마다 다른 표를 사용한다면 서로의 코드가 호환되지 않을 것이다. 그래서 표준화된 약속이 필요한데, 이를 **아스키코드**라고 부른다.
- 초기에는 1byte중 7bit에만 문자정보를 담았다가 나중에 확장 아스키코드라고도 불리는 ansi 코드로 발전했다.
    - ansi 코드는 1byte를 전부 사용한다. (8bit == 256개)
- 그러다가 코딩이 세계 각국으로 퍼지면서 표에 담아야할 문자들이 점점 늘어나서 **유니코드**라는 표준을 사용하기까지 이르렀다.
- 즉 C언어에서 **문자는 결국 "정수"**이기 때문에 변환도 가능하며 증감 및 비교 연산 또한 가능하다.

```c
#include <stdio.h>

int main(void)
{
    char small, cap = 'G';

    if (cap >= 'A' && cap <= 'Z')
        small = cap + ('a' - 'A');

    printf("대문자 : %c %c", cap, '\n');
    printf("소문자 : %c", small);

    return (0);
}
```

###     **1-2. scanf로 문자 입력**

- scanf는 입력을 저장한 버퍼에서 값을 읽어오는 함수다.
- scanf에서 문자를 입력받는 경우에는 white space (공백, 개행 등)를 주의해야 한다.
- 정수 등은 white space를 무시하지만, 문자는 white space도 문자로 인식한다.

```c
#include <stdio.h>

int main(void)
{
    char ch1, ch2;

    scanf("%c%c", &ch1, &ch2);
    printf("[%c%c]", ch1, ch2);

    return (0);
}
```

- 위 코드에서 `"ab"`를 입력하면 `[ab]` 출력, `"a b"`를 입력하면 `[a ]` 출력됨
- 해결책: `%c` 앞에 공백을 넣는다.

```c
scanf(" %c %c", &ch1, &ch2);
```

###     **1-3. putchar와 getchar로 문자 입출력**

```c
#include <stdio.h>

int main(void)
{
    int ch;

    ch = getchar();
    printf("input char : ");
    putchar(ch);
    putchar('\n');

    return (0);
}
```

- getchar는 입력을 한 글자 읽는다. 반환값은 `int`, 이유는 EOF(-1) 구분 때문.
- putchar는 문자를 출력하고, 해당 문자의 숫자를 반환한다.

###     **1-4. EOF 설명**

```
11111111 11111111 11111111 11111111 (EOF -1에 해당)
00000000 00000000 00000000 11111111 (255번 문자에 해당)
```

---

#
## **2. 버퍼**

### **2-1. 버퍼 개요**

- 버퍼는 운영체제에서 제공하는 임시 저장 공간입니다.
- 입력 장치(예: 키보드)로부터 사용자가 입력한 값은 곧바로 프로그램에 전달되는 것이 아니라, 먼저 이 버퍼에 저장됩니다.
- 이처럼 입력을 한꺼번에 모아두었다가 프로그램이 필요로 할 때 전달하는 구조는 효율적인 데이터 처리와 입력 장치의 호환성을 높이는 데 도움이 됩니다.

- 예를 들어, 사용자가 "hello"를 입력하고 엔터를 누르면 `h`, `e`, `l`, `l`, `o`, `
`이 버퍼에 저장됩니다.
- 이후 `scanf`, `getchar`와 같은 함수가 버퍼에서 데이터를 꺼내 사용하게 됩니다.
- 버퍼에 입력이 쌓이는 기준은 일반적으로 개행 문자(
)를 입력했을 때입니다. 이 개행 문자가 들어오면 운영체제는 그 전까지 입력된 데이터를 버퍼에 전달하고, 프로그램은 이 데이터를 읽을 수 있습니다.

- 버퍼를 사용하는 이유는 다음과 같습니다:
  - **호환성 유지**: 다양한 키보드나 입력 장치가 있더라도, 버퍼라는 중간 저장소를 사용하면 동일한 방식으로 입력을 처리할 수 있습니다.
  - **효율적인 입출력 처리**: 입력이 있을 때마다 즉시 처리하는 것이 아니라 모아서 한꺼번에 전달함으로써 성능 향상을 도모합니다.
  - **입력 편의성**: 사용자가 타이핑 중일 때도 입력이 저장되고, 엔터를 누르면 입력이 완료되므로 자연스럽고 직관적인 인터페이스를 제공합니다.

- 버퍼는 표준 입력(stdin), 표준 출력(stdout), 표준 에러(stderr)에도 각각 존재하며, 출력 버퍼도 flush(비우기) 타이밍에 따라 출력 시점이 달라질 수 있습니다.

- 또한 EOF (End Of File) 입력을 통해 버퍼 입력을 종료할 수 있습니다:
  - 윈도우: `Ctrl + Z`
  - macOS / Linux: `Ctrl + D`

- 이처럼 버퍼는 입력 흐름을 제어하고, 입력 효율을 높이는 데 매우 중요한 역할을 합니다.


### **2-2. scanf 활용**

```c
#include <stdio.h>

int main(void)
{
    int res;
    char ch;

    while(1)
    {
        res = scanf("%c", &ch);
        if (res == -1)
            break;
        printf("%d ", ch);
    }
    return (0);
}
```

###     **2-3. getchar 활용**

```c
#include <stdio.h>

void my_gets(char *str, int size)
{
    char ch;
    int i;

    for (i = 0; i < size; i++)
    {
        ch = getchar();
        if (ch != '\n')
            str[i] = ch;
        else
            break;
    }
    str[i] = 0;
}

int main(void)
{
    char str[7];

    my_gets(str, sizeof(str));
    printf("input line : %s\n", str);

    return (0);
}
```

---

### **3. 혼공C 11장 도전 실전 예제**

```c
#include <stdio.h>

int main(void)
{
    int cnt = 0, tmp = 0, ch;
    ch = getchar();

    while(ch != -1)
    {
        if (ch == '\n')
        {
            if (tmp > cnt)
                cnt = tmp;
            tmp = 0;
        }
        else
            tmp++;
        ch = getchar();
    }
    printf("가장 긴 단어의 길이 : %d\n", cnt);
    return (0);
}
```

---

## 📌 참고 자료

* 혼자 공부하는 C 언어
* [C언어 표준 라이브러리 - C Reference](https://en.cppreference.com/w/c/io)
