[⬅️ 상위 README로 이동](../README.md)
# 📘 C 배열과 문자열

## 📌 목차
- [0. 배열을 쓰는 이유](#0-배열을-쓰는-이유)
- [1. 배열 사용법](#1-배열-사용법)
  - [1-1. 배열 선언 및 초기화](#1-1-배열-선언-및-초기화)
  - [1-2. 배열 요소 접근 및 반복](#1-2-배열-요소-접근-및-반복)
  - [1-3. VLA (가변길이 배열)](#1-3-vla-가변길이-배열)
- [2. C에서의 문자열](#2-c에서의-문자열)
  - [2-1. char형 배열 선언 및 초기화](#2-1-char형-배열-선언-및-초기화)
  - [2-2. 주의 사항](#2-2-주의-사항)
- [3. 도전 실전 예제](#3-도전-실전-예제)

---

## **0. 배열을 쓰는 이유**

- 변수는 선언 시 메모리에 개별적으로 할당되며, 연속적이지 않다.
- 비슷한 데이터를 반복 처리할 때 각각 변수로 선언하면 관리가 힘들고 비효율적이다.
- 이러한 경우 **비슷한 자료를 연속된 메모리 공간에 모아 처리할 수 있는 배열(Array)**을 사용한다.

---

## **1. 배열 사용법**

### **1-1. 배열 선언 및 초기화**

- 배열은 `자료형 이름[요소 개수]` 형식으로 선언한다.
- 요소 개수는 상수 리터럴 또는 컴파일 시점에 결정되는 값이어야 한다.

```c
int arr[5];  // 정수형 배열 arr, 크기는 5
```

- 초기화는 중괄호 `{}`를 사용하여 한 번에 할 수 있다.

```c
int arr[5] = {1, 2, 3, 4, 5};
int arr[5] = {1, 2, 3}; // 나머지 요소는 자동으로 0으로 채워진다
int arr[5] = {0};       // 모든 요소를 0으로 초기화
```

- 배열 크기 생략 시 초기값 개수로 자동 결정된다.

```c
int arr[] = {1, 2, 3};  // 크기는 3
```

---

### **1-2. 배열 요소 접근 및 반복**

- 배열 인덱스는 0부터 시작한다.
- 선언과 접근은 구분되어야 한다: `int arr[5];`는 선언, `arr[2]`는 접근.

```c
#include <stdio.h>

int main(void) {
    int arr[5];
    int total = 0;
    double avg;

    for (int i = 0; i < 5; i++)
        scanf("%d", &arr[i]);

    for (int i = 0; i < 5; i++) {
        total += arr[i];
        printf("%5d", arr[i]);
    }

    avg = total / 5.0;
    printf("\n평균 : %.1lf\n", avg);
    return 0;
}
```

> ⚠️ **주의**: 배열 인덱스 초과 접근은 `segmentation fault`의 주요 원인이며 디버깅이 어렵다.
-   _**그냥 하는 소리가 아니라 간단한 예시를 보면 쉬워 보이지만 프로그램의 규모가 커지고 함수로 배열을 이리저리 주고 받다보면 seg fault (접근하면 안되는 메모리에 접근하면 생기는 오류)가 생기는데, 규모가 클수록 찾아내기도 어렵고 진짜 사람 생명력 빨아 먹는 부분이고, 참 아쉬운게 컴파일은 너무 잘돼서 코드 계속 들여다 보면서 찾아야 하므로 신경쓰는 연습이 많이 필요하다! 진짜로! (필자의 눈물로 쓰인 아주 개인적인 의견입니다.)**_
---

### **1-3. VLA (가변길이 배열)**

- C99에서 도입된 기능으로, 런타임에 배열 크기를 지정할 수 있다.

```c
#include <stdio.h>

int main(void) {
    int n;
    scanf("%d", &n);

    int arr[n]; // 런타임에 결정됨
}
```

- VLA는 **스택에 할당**되며, **메모리 해제를 직접 하지 않아도 됨**.
- 단, 너무 큰 크기 지정 시 스택 오버플로우 발생 가능성 있음.
- C11부터는 VLA 지원이 필수가 아님.

---

## **2. C에서의 문자열**

- C에는 문자열 자료형이 없으며, **문자 배열(char[])**로 문자열을 표현한다.

### **2-1. char형 배열 선언 및 초기화**

```c
char str[80] = "applejam";
```

- 위 코드는 내부적으로 다음과 같다:

```c
char str[80] = {'a','p','p','l','e','j','a','m','\0'};
```

```c
#include <stdio.h>

int main(void) {
    char str[80] = "applejam";

    printf("init line : %s\n", str);
    printf("input new line : ");
    scanf("%s", str);
    printf("new line : %s\n", str);

    return 0;
}
```

---

### **2-2. 주의 사항**

- 문자열 처리 시에는 반드시 **널문자(\0)**까지 고려하여 배열을 선언해야 한다.
- `gets`, `strcpy` 등 버퍼 크기를 확인하지 않는 함수는 위험하며 사용을 지양해야 한다.
- C99 이후로는 `fgets`, `strncpy`, `strlcpy` 등 안전한 함수 사용을 권장한다.

---

## **3. 도전 실전 예제**

### 대소문자 변환 및 개수 세기

```c
#include <stdio.h>

int main(void) {
    char str[100];
    char str2[100];
    int cnt = 0;

    printf("문장 입력 : ");
    gets(str); // ⚠️ 비권장 함수

    int i = 0;
    while (str[i]) {
        if (str[i] >= 'A' && str[i] <= 'Z') {
            str2[i] = str[i] - 'A' + 'a';
            cnt++;
        } else {
            str2[i] = str[i];
        }
        i++;
    }

    str2[i] = 0;
    printf("바뀐 문장 : %s\n", str2);
    printf("바뀐 문자 수 : %d\n", cnt);
}
```

> 💡 실제 환경에서는 `fgets(str, sizeof(str), stdin)`으로 대체하는 것이 안전합니다.
